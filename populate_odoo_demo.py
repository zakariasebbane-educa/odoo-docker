#!/usr/bin/env python3
"""
Populate an Odoo 17 database with demo data for consulting / SQL exercises.

Creates:
 - customers (res.partner)
 - products (product.product / product.template)
 - sale.orders with lines (sale_order, sale_order_line)
 - a couple of invoices (account.move) from some orders (optional)
 
Idempotent: it checks existing records by 'ref' names it writes.
Usage:
  python3 populate_odoo_demo.py --url http://localhost:8069 --db demo_consulting --user admin@example.com --password admin
"""

import argparse
import random
import xmlrpc.client
from datetime import datetime, timedelta

def parse_args():
    p = argparse.ArgumentParser()
    p.add_argument("--url", default="http://localhost:8069", help="Odoo base URL")
    p.add_argument("--db", default="demo_consulting", help="Odoo DB name")
    p.add_argument("--user", required=True, help="Odoo admin email/login")
    p.add_argument("--password", required=True, help="Odoo admin password")
    p.add_argument("--customers", type=int, default=20, help="Number of customers to create")
    p.add_argument("--products", type=int, default=12, help="Number of products to create")
    p.add_argument("--seed", type=int, default=42, help="Random seed")
    return p.parse_args()

def connect(url, db, user, password):
    common = xmlrpc.client.ServerProxy(f"{url}/xmlrpc/2/common")
    uid = common.authenticate(db, user, password, {})
    if not uid:
        raise SystemExit("Authentication failed: check DB/user/password and URL.")
    models = xmlrpc.client.ServerProxy(f"{url}/xmlrpc/2/object")
    return uid, models

def search_or_create_partner(models, uid, password, name, is_company=True, email=None, country_id=None, ref=None):
    domain = [["name","=",name]]
    found = models.execute_kw(db, uid, password, 'res.partner', 'search', [domain], {"limit":1})
    if found:
        return found[0]
    vals = {"name": name, "is_company": is_company, "customer_rank": 1}
    if email: vals["email"] = email
    if ref: vals["ref"] = ref
    if country_id: vals["country_id"] = country_id
    partner_id = models.execute_kw(db, uid, password, 'res.partner', 'create', [vals])
    print("Created partner:", name, "=>", partner_id)
    return partner_id

def search_or_create_product(models, uid, password, name, list_price=100.0, default_code=None):
    domain = [["name","=",name]]
    found = models.execute_kw(db, uid, password, 'product.template', 'search', [domain], {"limit":1})
    if found:
        # need product.product id
        prod_t = models.execute_kw(db, uid, password, 'product.template', 'read', [found], {"fields": ["product_variant_ids"]})
        return prod_t[0]["product_variant_ids"][0]
    vals = {"name": name, "list_price": list_price}
    if default_code: vals["default_code"] = default_code
    tmpl_id = models.execute_kw(db, uid, password, 'product.template', 'create', [vals])
    prod = models.execute_kw(db, uid, password, 'product.template', 'read', [[tmpl_id]], {"fields": ["product_variant_ids"]})
    prod_id = prod[0]["product_variant_ids"][0]
    print("Created product:", name, "=> tmpl", tmpl_id, "prod", prod_id)
    return prod_id

def create_sale_order(models, uid, password, partner_id, order_lines, date_order):
    # Order reference will be autogenerated; we can add our own client_order_ref for idempotency if needed
    order_vals = {
        "partner_id": partner_id,
        "order_line": order_lines,
        "date_order": date_order.strftime("%Y-%m-%d %H:%M:%S"),
    }
    order_id = models.execute_kw(db, uid, password, 'sale.order', 'create', [order_vals])
    return order_id

def create_order_line_tuple(product_id, qty, price_unit):
    # format for many2many command with 0 means create line inline
    line_vals = (0, 0, {
        "product_id": product_id,
        "product_uom_qty": qty,
        "price_unit": price_unit,
    })
    return line_vals

def maybe_create_invoice_from_order(models, uid, password, order_id):
    # Try to create invoice via sale.order action (may require invoicing module). We'll attempt a simple approach:
    try:
        # create invoice through _create_invoices or action_invoice_create depending on version
        inv_ids = models.execute_kw(db, uid, password, 'sale.order', 'action_create_invoice', [[order_id]])
        # older versions used action_invoice_create - but that may not exist
        if inv_ids:
            print("Created invoice(s)", inv_ids, "for order", order_id)
            return inv_ids
    except Exception:
        pass
    # fallback: create a simple account.move (invoice) record (basic)
    try:
        order = models.execute_kw(db, uid, password, 'sale.order', 'read', [[order_id]], {"fields":["partner_id","amount_total"]})[0]
        partner = order["partner_id"][0] if order.get("partner_id") else None
        if not partner:
            return []
        move_vals = {
            "move_type": "out_invoice",
            "partner_id": partner,
            "invoice_date": datetime.now().strftime("%Y-%m-%d"),
            "invoice_origin": f"SO{order_id}",
        }
        move_id = models.execute_kw(db, uid, password, 'account.move', 'create', [move_vals])
        models.execute_kw(db, uid, password, 'account.move', 'action_post', [[move_id]])
        print("Fallback invoice created:", move_id)
        return [move_id]
    except Exception as e:
        print("Could not create invoice for order", order_id, ":", e)
        return []

if __name__ == "__main__":
    args = parse_args()
    random.seed(args.seed)
    url = args.url
    db = args.db
    user = args.user
    password = args.password

    print("Connecting to", url, "db:", db)
    uid, models = connect(url, db, user, password)
    print("Connected. UID:", uid)

    # 1) Create products
    product_ids = []
    for i in range(1, args.products + 1):
        pid = search_or_create_product(models, uid, password, f"Demo Product {i}", list_price=round(10 + random.random() * 90, 2), default_code=f"DP{i:03d}")
        product_ids.append(pid)

    # 2) Create customers (partners).
    partner_ids = []
    for i in range(1, args.customers + 1):
        name = f"Customer {i:02d}"
        email = f"customer{i:02d}@example.com"
        pid = search_or_create_partner(models, uid, password, name, is_company=True, email=email, ref=f"CUST{i:03d}")
        partner_ids.append(pid)

    # 3) Force two "big" customers to have >5 orders in last 30 days
    big_customers = [partner_ids[0], partner_ids[1]]
    for idx, cust in enumerate(big_customers):
        orders_needed = 8
        for j in range(orders_needed):
            # date in last 25 days
            delta = random.randint(0, 24)
            date_order = datetime.now() - timedelta(days=delta, hours=random.randint(0,23))
            # 1-3 lines
            lines = []
            for _ in range(random.randint(1,3)):
                prod = random.choice(product_ids)
                qty = random.randint(1,10)
                price = round(random.uniform(10, 200), 2)
                lines.append(create_order_line_tuple(prod, qty, price))
            oid = create_sale_order(models, uid, password, cust, lines, date_order)
        print("Created", orders_needed, "recent orders for big customer", cust)

    # 4) Create random orders for other customers across last 60 days
    for cust in partner_ids[2:]:
        n_orders = random.randint(1, 8)
        for _ in range(n_orders):
            delta = random.randint(0, 59)
            date_order = datetime.now() - timedelta(days=delta, hours=random.randint(0,23))
            lines = []
            for _ in range(random.randint(1,3)):
                prod = random.choice(product_ids)
                qty = random.randint(1,8)
                price = round(random.uniform(5, 300), 2)
                lines.append(create_order_line_tuple(prod, qty, price))
            create_sale_order(models, uid, password, cust, lines, date_order)

    print("Finished creating products, partners and sale orders.")
    print()
    print("To verify via SQL in pgAdmin or psql, you can run e.g.:")
    print("""
SELECT partner_id, COUNT(*) AS total_orders
FROM sale_order
WHERE date_order >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY partner_id
HAVING COUNT(*) > 5;
""")
    print()
    print("Script finished.")
